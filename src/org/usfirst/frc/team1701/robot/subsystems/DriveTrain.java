// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team1701.robot.subsystems;

import org.usfirst.frc.team1701.robot.Robot;
import org.usfirst.frc.team1701.robot.RobotMap;
import org.usfirst.frc.team1701.robot.commands.AutonomousCommand;
import org.usfirst.frc.team1701.robot.commands.TeleopDrive;

import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class DriveTrain extends Subsystem implements PIDOutput {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final SpeedController left_1 = RobotMap.driveTrainLeft_1;
	private final SpeedController left_2 = RobotMap.driveTrainLeft_2;
	private final SpeedController right_1 = RobotMap.driveTrainRight_1;
	private final SpeedController right_2 = RobotMap.driveTrainRight_2;
	private boolean reversed = true;
	private final double DIST_ADJUST_CONST = 1052.6;
	private boolean precise = false;
	// private final RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;

	private PIDController pid;
	static final double kP = 0.03;
	static final double kI = 0.00;
	static final double kD = 0.00;
	static final double kF = 0.00;
	static final double kToleranceDegrees = 2.0;
	private double rate;
	private double startAngle;
	private double actualDriveSpeed;
	private final boolean STRAIGHTEN_WITH_PID = false; // make true to use
														// experimental PID
														// straightening

	public double getActualDriveSpeed() {
		return actualDriveSpeed;
	}

	public void setActualDriveSpeed(double actualDriveSpeed) {
		this.actualDriveSpeed = actualDriveSpeed;
	}

	public double getStartAngle() {
		return startAngle;
	}

	public void setupPID () {
		pid = new PIDController(kP, kI, kD, kF, RobotMap.navx, this);
		pid.setInputRange(-180, 180);
		pid.setOutputRange(-.5, .5);
		pid.setAbsoluteTolerance(kToleranceDegrees);
		pid.setContinuous(true);
		pid.enable();
	}
	
	public void setPIDtoAngle(double startAngle) {
		this.startAngle = startAngle;
		pid.setSetpoint(startAngle);
	}

	public boolean isPIDnull() {
		return (pid == null);
	}

	public boolean isPrecise() {
		return precise;
	}

	public void setPrecise(boolean precise) {
		this.precise = precise;
	}

	// whichever Talon has the encoder on each side
	private final CANTalon leftEncTalon = (CANTalon) left_2;// this is Talon 3
	private final CANTalon rightEncTalon = (CANTalon) right_1;// this is Talon
																// 12

	private final double WHEEL_CIRCUMFERENCE = 3.9 * Math.PI;
	private final int PULSES_PER_ROTATION = 1440;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	public void setup() {
		leftEncTalon.configEncoderCodesPerRev(PULSES_PER_ROTATION);
		rightEncTalon.configEncoderCodesPerRev(PULSES_PER_ROTATION);
	}

	public void enablePID() {
		pid.enable();
	}

	public void disablePID() {
		pid.disable();
	}

	public int getLeftVelocity() {
		return leftEncTalon.getEncVelocity();
	}

	public double getLeftDistance() {
		return leftEncTalon.getEncPosition() * WHEEL_CIRCUMFERENCE / DIST_ADJUST_CONST;
	}

	public void resetLeftEncoder() {
		leftEncTalon.setEncPosition(0);
	}

	public int getRightVelocity() {
		return rightEncTalon.getEncVelocity();
	}

	public double getRightDistance() {
		return -rightEncTalon.getEncPosition() * WHEEL_CIRCUMFERENCE / DIST_ADJUST_CONST;
	}

	public void resetRightEncoder() {
		rightEncTalon.setEncPosition(0);
	}

	public void toggleReversed() {
		if (reversed) {
			reversed = false;
		} else
			reversed = true;
	}

	public void preparePIDForTeleop() {
//		pid.setInputRange(-.75, .75);
		//pid.setOutputRange(-.75, .75);
	}
	/*
	 * public double getGyroReading(){ return driveGyro.getAngle(); } public
	 * void resetGyro(){ driveGyro.reset(); }
	 */

	public void leftDriveControl(double inputSpeed) {
		/*
		 * two motors are used to control one wheel per side (total 4 motors),
		 * so they have to have the same input
		 * 
		 * can instead make one motor a slave to the other (one follows the
		 * others signal always)
		 */
		left_1.set(inputSpeed);
		left_2.set(inputSpeed);
	}

	public void rightDriveControl(double inputSpeed) {
		/*
		 * two motors are used to control one wheel per side (total 4 motors),
		 * so they have to have the same input
		 */
		right_1.set(inputSpeed);
		right_2.set(inputSpeed);
	}

	public void teleopControl(double forwardsBackwardsAxis, double turningAxis) {
		if (reversed) {
			forwardsBackwardsAxis *= -1;
		}

		if (precise) {
			forwardsBackwardsAxis *= .5;
			turningAxis *= .75;
		}
//		if (STRAIGHTEN_WITH_PID) {
//			pid.setSetpoint(turningAxis*180);
//			RobotMap.driveTrainRM.arcadeDrive(forwardsBackwardsAxis, rate);
//		} else
			RobotMap.driveTrainRM.arcadeDrive(forwardsBackwardsAxis, turningAxis);
	}

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new TeleopDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void driveBackwardsPID() {

		if (Math.abs(actualDriveSpeed) < Math.abs(AutonomousCommand.AUTO_DRIVE_SPEED))
			actualDriveSpeed += .03;
		RobotMap.driveTrainRM.arcadeDrive(actualDriveSpeed, rate);
	}

	@Override
	public void pidWrite(double output) {
		// TODO Auto-generated method stub
		rate = output;
	}
}
